Project Setup

Core Layer
	AutoMapper
	Packages used:
		- AutoMapper
		- AutoMapper.Extensions.Microsoft.DependencyInjection
		
	Use:
		- Used when we do not want to pass around domain entity around in our application. 
		- Create DTO that models from entity.
			Read from DB - Data from DB is fed to DTO & using automapper, DTO maps to Model which is passed to View
			Save to DB - Model passed from view is fed to DTO using autoMapper and DTO is used to save to DB
			
	CQRS
	Packages used:
		- MediatR
	Use:
		Command Query Responsibility Segregation
			Query = Read from DB
			Command = Write to dB
			
		Per ideal implementation of pattern, we would have different data stores for read/write.
		For ex: Primary DB does the writes & read ops come from Read Replica etc.
		
		Promotes THIN CONTROLLERS. Business Logic moved to HANDLERS
		
		
	FluentValidations
	Packages used:
		- FluentValidation
		- FluentValidation.DependencyInjectionExtensions
		
	Use:
		- Perform validations against DTOs
		- Uses BuilderPattern to extend validations
		- For a particular property, we can specify rules
		- It has a lot of built-in validation checks like .NotEmpty(), .NotNull() etc.
		- If needed, we can write our own custom validations as well.
			For ex: If we want to add a check that while creating a leave, we want to ensure LeaveName is unique(LeaveName entered while creating does not match with any existing leavename present in DB)?, we can do it
		
Infra Layer

	Setting up EF:
	Package used:
		Microsoft.EntityFrameworkCore.SqlServer
		Microsoft.Extensions.Options.ConfigureExtensions
		
	DBContext = Bridge between code and DB. Uses Connectionstring to mediate
	Flagship ORM from Microsoft
	
	Setting up Email Service: SendGrid
	Package used:
		SendGrid
		
	Used Options Pattern here.
	Package required:
		Microsoft.Extensions.Options.ConfigurationExtensions
	
	
API Layer:

	All individual class libraries have extension methods defined:
		ApplicationServiceRegistration
		InfrastructureServiceRegistration
		PersistenceServiceRegistration etc.
		
	Since all are going to be used in API, we need to call those extension methods from WebAPI's Program.cs
	
Scaffolding DBs:

Package used(To WebAPI):
	Microsoft.EntityFrameworkCore.Tools
	
	Now, open PackageManagerConsole and choose a correct default package
	Our DB related code sits in Persistence project
	When we run "Add-Migration", it will generate a folder namely Migration
	A new migration will be added with whatever message we have. That class will have 2 methods : Up and Down.
	Up -> Code to create new/update existing tables
	Down -> Revert it
	
	Next command to actually execute the DB is to use "Update-Database"
	Upon successful execution, EFCore will generate SQL statements

	--SideNote - Issues faced while installing SQL Server 2019. Had a few bad deployments due to errors while starting up
	--Resolved by following this link - https://learn.microsoft.com/en-us/troubleshoot/sql/database-engine/database-file-operations/troubleshoot-os-4kb-disk-sector-size
	
	
	Creating the controller
	When we inject the mediator, it will automatically find the handler using the TRequest we use.
	var leaveTypes = await _mediator.Send(new GetLeaveTypesQuery());
	When we write above line mediator finds the handler that takes in GetLeaveTypesQuery object and returns the TResponse object
	
	
	When working with Validators, if we have some common validators that are required in two or more commands/queries etc.,
	we can create a baseValidator and include then in the child validators using Include() keyword.
	
	Refer BaseLeaveRequestValidator
	            
	Global Error Handling
	Since we have a lot of different custom types of exception, we need to have a central place to handle them and return the correct status back
	That's where middleware come into action
	
	Created a middleware and injected in HTTP request pipeline.
	Also created a CustomProblemDetails that inherits from ProblemDetails & added a custom property there namely Errors
	Also, handled scenario in the middleware
	
Section#7 - Testing:
	Write Automated Tests:
		Validate code operates as expected
		Tests known or expected outcomes
		Best implemented when code is clean & modular
		Easier to accomplish when code is loosely coupled

	Cover unit and integration tests
	XUnit, Moq, Shouldly
	
	Tests typically consists of 3A's
		Arrange
		Act
		Assert

	Unit Tests:
		Added unit test project.
		Project type: xUnit
		Packages:
			Moq
			Shouldly
			
			Other added by default when we created xUnit project:
			coverlet.collector
			Microsoft.NET.Test.Sdk
			xunit
			xunit.runner.visualstudio
			
		Why use mocks?
			For actual application, we'd be using DI to resolve the interfaces and maybe connect to DB or do calls to external endpoints
			However for unit tests, we do not need those actuals to work. Hence we use mocks of those typess
			
			Ideally -> Better to just add Tests keyword against the class we're testing against
		
		XUnit test types:
			Fact - Straight forward testing
			Theory - Provide inline data and do conditional tests
			
	Integration tests:
		Validate behaviors of 3rd party frameworks and technologies
			- For ex: EFCore is our app's integration to DB
			
	Added unit test project.
	Project type: xUnit
	Packages:
		Moq
		Shouldly
		Microsoft.EntityFrameworkCore.InMemory
			
	Why use EFCore.InMemory?
		It's a DB provider for EFCore to be used ONLY for testing purposes
		Just to simulate test DB in memory for writing tests
		
Section#8
	Blazor - .NET Single Page Application development Framework
	NSwag and NSwagStudio - Generate API integration code
	Configure JWT security
		- Admin/Employee role
	Setup UI for leave management features
	
	Added Blazor WebAssembly project
	
	Blazor Project structure
		Properties
			LaunchSettings.json
				- Similar to .NET Core WebAPI. Can configure environment vars, startup settings etc. here
		wwwroot
			All css, js, images, static content to go here
			Contains index.html which is like the base/master page of our app
			<div id="app">
				<!--Entire app gets rendered here-->
			</div>
		Pages
			Individual pages. Pages have razor syntax
		Shared
			All shared components sit here. They can be reused in Pages
		Imports.razor
			Standalone file that contains using statements that'll be globally present throughout the UI
		App.razor
			Setup routing and different interceptors
		Program.cs
			Configuring the UI project.
			